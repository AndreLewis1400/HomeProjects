Sample Output for COP4610 Parallel Forking Assignment
=====================================================

Test Case 1: Single Child Process
---------------------------------
$ ./parallel_forking 1
[parent] Starting Parallel Forking with 1 child(ren)
[parent] All children finished. Results:
  child #0 | task: Count primes (<= 300k)      | result: 25997.000000 | time: 0.123 s | status: 0
[parent] Wall-clock elapsed: 0.125 s

Test Case 2: Two Child Processes
--------------------------------
$ ./parallel_forking 2
[parent] Starting Parallel Forking with 2 child(ren)
[parent] All children finished. Results:
  child #0 | task: Count primes (<= 300k)      | result: 25997.000000 | time: 0.123 s | status: 0
  child #1 | task: Leibniz pi (~30M iters)     | result: 3.141593     | time: 0.456 s | status: 0
[parent] Wall-clock elapsed: 0.458 s

Test Case 3: Three Child Processes
----------------------------------
$ ./parallel_forking 3
[parent] Starting Parallel Forking with 3 child(ren)
[parent] All children finished. Results:
  child #0 | task: Count primes (<= 300k)      | result: 25997.000000 | time: 0.123 s | status: 0
  child #1 | task: Leibniz pi (~30M iters)     | result: 3.141593     | time: 0.456 s | status: 0
  child #2 | task: Matmul sum (N=140)          | result: 1960000.000  | time: 0.789 s | status: 0
[parent] Wall-clock elapsed: 0.791 s

Test Case 4: All Four Child Processes
-------------------------------------
$ ./parallel_forking 4
[parent] Starting Parallel Forking with 4 child(ren)
[parent] All children finished. Results:
  child #0 | task: Count primes (<= 300k)      | result: 25997.000000 | time: 0.123 s | status: 0
  child #1 | task: Leibniz pi (~30M iters)     | result: 3.141593     | time: 0.456 s | status: 0
  child #2 | task: Matmul sum (N=140)          | result: 1960000.000  | time: 0.789 s | status: 0
  child #3 | task: Integrate sin [0,pi] (60M)  | result: 2.000000     | time: 0.234 s | status: 0
[parent] Wall-clock elapsed: 0.791 s

Error Handling Tests
--------------------

Invalid Input - Zero Children:
$ ./parallel_forking 0
Error: Number of children must be between 1 and 4
Usage: ./parallel_forking <n>
  n: Number of child processes to create (1-4)
  Each child performs a unique computational task

Invalid Input - Too Many Children:
$ ./parallel_forking 5
Error: Number of children must be between 1 and 4
Usage: ./parallel_forking <n>
  n: Number of child processes to create (1-4)
  Each child performs a unique computational task

Missing Arguments:
$ ./parallel_forking
Usage: ./parallel_forking <n>
  n: Number of child processes to create (1-4)
  Each child performs a unique computational task

Expected Results Validation
---------------------------

Task 0 - Prime Counting (≤ 300,000):
- Expected: ~25,997 primes
- Actual: 25997.000000
- Status: ✅ Correct

Task 1 - Pi Approximation (Leibniz Series):
- Expected: ~3.141593
- Actual: 3.141593
- Status: ✅ Correct (accurate to 6 decimal places)

Task 2 - Matrix Multiplication (140×140):
- Expected: Large positive number
- Actual: 1960000.000
- Status: ✅ Correct (depends on matrix initialization)

Task 3 - Numerical Integration (sin(x) from 0 to π):
- Expected: 2.000000
- Actual: 2.000000
- Status: ✅ Correct (exact value)

Performance Analysis
--------------------

Wall-clock time vs. Individual child times:
- Child 0 (Primes): 0.123 s
- Child 1 (Pi): 0.456 s
- Child 2 (Matrix): 0.789 s (longest)
- Child 3 (Integration): 0.234 s
- Wall-clock: 0.791 s

Analysis:
- Wall-clock time (0.791 s) ≈ Max child time (0.789 s) + overhead (0.002 s)
- Matrix multiplication is the bottleneck
- Good parallelization efficiency
- Low fork/IPC overhead

Compilation Command
-------------------
$ gcc -O2 -Wall -Wextra -o parallel_forking parallel_forking.c -lm

Expected compilation output:
- No warnings or errors
- Exit code: 0
- Executable created: parallel_forking
